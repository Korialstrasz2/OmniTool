{% extends 'base.html' %}
{% block content %}
  <h2>Lyrics Embedder Manager</h2>
  <p class="lead">
    Scan a music library, fetch lyrics from multiple providers, and embed them into audio tags.
    You can tune concurrency, retries, cache behavior, and optionally trigger AI metadata recovery when providers fail.
  </p>

  <section class="card card-soft">
    <div class="card-header">
      <h3>Configuration</h3>
      <p>Persist default options for repeat runs from this dashboard.</p>
    </div>
    <form class="stack" method="post" action="{{ url_for('lyrics_embedder_save_settings') }}">
      <div class="form-grid">
        <label>
          <span>Music folder</span>
          <input type="text" name="root_path" value="{{ settings['root_path'] }}" required>
        </label>
        <label>
          <span>Parallel bots (workers)</span>
          <input type="number" name="workers" min="1" value="{{ settings['workers'] }}" required>
        </label>
        <label>
          <span>Max in-flight jobs (0 = auto)</span>
          <input type="number" name="max_inflight" min="0" value="{{ settings['max_inflight'] }}">
        </label>
      </div>

      <div class="form-grid">
        <label>
          <span>Timeout (seconds)</span>
          <input type="text" name="timeout" value="{{ settings['timeout'] }}">
        </label>
        <label>
          <span>Retries per provider</span>
          <input type="number" name="retries" min="1" value="{{ settings['retries'] }}">
        </label>
        <label>
          <span>Backoff base</span>
          <input type="text" name="backoff" value="{{ settings['backoff'] }}">
        </label>
      </div>

      <div class="form-grid">
        <label>
          <span>Min delay between provider calls (seconds)</span>
          <input type="text" name="min_delay" value="{{ settings['min_delay'] }}">
        </label>
        <label>
          <span>Status heartbeat (seconds)</span>
          <input type="text" name="status_every" value="{{ settings['status_every'] }}">
        </label>
        <label>
          <span>Cache flush every N files</span>
          <input type="number" name="cache_flush_every" min="1" value="{{ settings['cache_flush_every'] }}">
        </label>
      </div>

      <div class="form-grid">
        <label>
          <span>Max files (0 = no cap)</span>
          <input type="number" name="max_files" min="0" value="{{ settings['max_files'] }}">
        </label>
        <label>
          <span>AI rounds on failure</span>
          <input type="number" name="ai_rounds" min="0" value="{{ settings['ai_rounds'] }}">
        </label>
        <label>
          <span>AI model</span>
          <input type="text" name="ai_model" value="{{ settings['ai_model'] }}">
        </label>
        <label>
          <span>AI log file path</span>
          <input type="text" name="ai_log_file" value="{{ settings.get('ai_log_file', '') }}">
        </label>
      </div>

      <div class="form-grid">
        <label>
          <span>Extensions</span>
          <input type="text" name="exts" value="{{ settings['exts'] }}">
        </label>
        <label>
          <span>Log level</span>
          <select name="log_level">
            {% for level in ['DEBUG', 'INFO', 'WARNING', 'ERROR'] %}
              <option value="{{ level }}" {% if settings['log_level'] == level %}selected{% endif %}>{{ level }}</option>
            {% endfor %}
          </select>
        </label>
        <label>
          <span>Optional log file path</span>
          <input type="text" name="log_file" value="{{ settings['log_file'] }}">
        </label>
      </div>

      <label class="checkbox-inline">
        <input type="checkbox" name="ai_if_failed" value="1" {% if settings.get('ai_if_failed', '1') != '0' %}checked{% endif %}>
        <span>Default to <strong>AI if failed</strong> on run</span>
      </label>

      <button type="submit">Save defaults</button>
    </form>
  </section>

  <section class="card card-soft">
    <div class="card-header">
      <h3>Run job</h3>
      <p>Launches <code>scripts/lyrics_embedder.py</code> in the background.</p>
    </div>
    <form class="stack" method="post" action="{{ url_for('lyrics_embedder_run') }}">
      <input type="hidden" name="root_path" value="{{ settings['root_path'] }}">
      <input type="hidden" name="workers" value="{{ settings['workers'] }}">
      <input type="hidden" name="max_inflight" value="{{ settings['max_inflight'] }}">
      <input type="hidden" name="min_delay" value="{{ settings['min_delay'] }}">
      <input type="hidden" name="timeout" value="{{ settings['timeout'] }}">
      <input type="hidden" name="retries" value="{{ settings['retries'] }}">
      <input type="hidden" name="backoff" value="{{ settings['backoff'] }}">
      <input type="hidden" name="status_every" value="{{ settings['status_every'] }}">
      <input type="hidden" name="cache_flush_every" value="{{ settings['cache_flush_every'] }}">
      <input type="hidden" name="max_files" value="{{ settings['max_files'] }}">
      <input type="hidden" name="ai_rounds" value="{{ settings['ai_rounds'] }}">
      <input type="hidden" name="ai_model" value="{{ settings['ai_model'] }}">
      <input type="hidden" name="ai_log_file" value="{{ settings.get('ai_log_file', '') }}">
      <input type="hidden" name="exts" value="{{ settings['exts'] }}">
      <input type="hidden" name="log_level" value="{{ settings['log_level'] }}">
      <input type="hidden" name="log_file" value="{{ settings['log_file'] }}">

      <fieldset class="options">
        <legend>Run flags</legend>
        <label><input type="checkbox" name="force" value="1"> Force overwrite existing lyrics</label>
        <label><input type="checkbox" name="keep_synced" value="1"> Keep synced LRC timestamps if returned</label>
        <label><input type="checkbox" name="ai_if_failed" value="1" {% if settings.get('ai_if_failed', '1') != '0' %}checked{% endif %}> AI if failed (metadata recovery + re-query providers)</label>
      </fieldset>
      <p class="help-text">AI mode requires <code>OPENAI_API_KEY</code> and the <code>openai</code> package installed.</p>
      <button type="submit">Start lyrics embedding</button>
    </form>
  </section>


  <section class="card card-soft">
    <div class="card-header logs-head">
      <div>
        <h3>AI connectivity check</h3>
        <p>Send a small request to the configured model and show either the response or a detailed error.</p>
      </div>
      <button type="button" id="ai-ping-btn">AI PING</button>
    </div>
    <p class="help-text">Uses model <code id="ai-ping-model">{{ settings['ai_model'] }}</code> and requires <code>OPENAI_API_KEY</code>.</p>
    <pre id="ai-ping-output" class="logs-output">Click AI PING to test the OpenAI request path.</pre>
  </section>

  <section class="card card-soft">
    <div class="card-header logs-head">
      <div>
        <h3>Logs</h3>
        <p>Live tail from the configured log file, with client-side filtering.</p>
      </div>
      <button type="button" id="refresh-logs">Refresh</button>
    </div>
    <div class="form-grid logs-filters">
      <label>
        <span>Level filter</span>
        <select id="log-level-filter">
          <option value="">All</option>
          <option value="DEBUG">DEBUG</option>
          <option value="INFO">INFO</option>
          <option value="WARNING">WARNING</option>
          <option value="ERROR">ERROR</option>
        </select>
      </label>
      <label>
        <span>Search text</span>
        <input id="log-query-filter" type="text" placeholder="artist, timeout, cache...">
      </label>
      <label>
        <span>Max lines</span>
        <input id="log-max-lines" type="number" min="50" max="2000" value="300">
      </label>
    </div>
    <p class="help-text" id="log-path"></p>
    <pre id="logs-output" class="logs-output">Loading logs...</pre>
  </section>

  <script>
    (function () {
      const refreshBtn = document.getElementById('refresh-logs');
      const aiPingBtn = document.getElementById('ai-ping-btn');
      const aiPingOutput = document.getElementById('ai-ping-output');
      const aiPingModel = document.getElementById('ai-ping-model');
      const logsOutput = document.getElementById('logs-output');
      const logPath = document.getElementById('log-path');
      const levelFilter = document.getElementById('log-level-filter');
      const queryFilter = document.getElementById('log-query-filter');
      const maxLines = document.getElementById('log-max-lines');


      async function pingAiService() {
        const model = {{ settings['ai_model']|tojson }};
        aiPingOutput.textContent = 'Pinging AI service...';
        aiPingModel.textContent = model || 'N/A';
        try {
          const formData = new FormData();
          formData.set('ai_model', model || '');
          const response = await fetch('{{ url_for('lyrics_embedder_ai_ping') }}', {
            method: 'POST',
            body: formData,
          });
          const payload = await response.json();
          if (payload.ok) {
            aiPingOutput.textContent = `✅ Model: ${payload.model}\n\n${payload.response}`;
            return;
          }
          const details = [
            `❌ Model: ${payload.model || model || 'unknown'}`,
            `Error: ${payload.error || 'Unknown error'}`,
          ];
          if (payload.raw_response) {
            details.push('', `Raw response: ${payload.raw_response}`);
          }
          aiPingOutput.textContent = details.join('\n');
        } catch (error) {
          aiPingOutput.textContent = `❌ Request failed before response parsing: ${error}`;
        }
      }

      async function refreshLogs() {
        const params = new URLSearchParams({
          level: levelFilter.value,
          q: queryFilter.value,
          max_lines: maxLines.value || '300',
          log_file: {{ settings['log_file']|tojson }},
        });
        logsOutput.textContent = 'Loading logs...';
        try {
          const response = await fetch(`{{ url_for('lyrics_embedder_logs') }}?${params.toString()}`);
          const payload = await response.json();
          logPath.textContent = `Source: ${payload.log_path || 'N/A'}`;
          if (!payload.ok) {
            logsOutput.textContent = payload.message || 'No logs yet.';
            return;
          }
          logsOutput.textContent = payload.lines.length ? payload.lines.join('\n') : 'No matching log lines.';
        } catch (error) {
          logsOutput.textContent = `Unable to load logs: ${error}`;
        }
      }

      refreshBtn.addEventListener('click', refreshLogs);
      aiPingBtn.addEventListener('click', pingAiService);
      levelFilter.addEventListener('change', refreshLogs);
      queryFilter.addEventListener('input', refreshLogs);
      maxLines.addEventListener('change', refreshLogs);

      refreshLogs();
      setInterval(refreshLogs, 5000);
    })();
  </script>
{% endblock %}
